name: Deploy to k3s

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  DROPLET_IP: ${{ secrets.DIGITALOCEAN_HOST }}
  DROPLET_USER: root
  SSH_PRIVATE_KEY: ${{ secrets.DIGITALOCEAN_SSH_KEY }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r services/feed-ingestion/requirements.txt
        pip install requests  # For testing
    
    - name: Validate Python imports
      run: |
        echo "üîç Validating Python imports..."
        
        # Debug: Check directory structure
        echo "üìÅ Checking directory structure..."
        ls -la
        echo "üìÅ Checking services directory..."
        ls -la services/ || echo "No services directory found"
        echo "üìÅ Checking services/feed-ingestion directory..."
        ls -la services/feed-ingestion/ || echo "No feed-ingestion directory found"
        
        # Test ingestion service imports
        echo "Testing ingestion service imports..."
        python -c "
        import sys
        import os
        
        # Add the correct paths
        current_dir = os.getcwd()
        print(f'Current directory: {current_dir}')
        
        # Add project root and services directory to Python path
        sys.path.insert(0, current_dir)
        sys.path.insert(0, os.path.join(current_dir, 'services', 'feed-ingestion'))
        
        print(f'Python path: {sys.path}')
        
        # Test basic imports - use the correct module names
        try:
            # Import from the feed-ingestion directory directly
            from main import app
            print('‚úÖ Ingestion service main imports successful')
        except ImportError as e:
            print(f'‚ùå Ingestion service main import error: {e}')
            sys.exit(1)
        
        # Test runner imports
        try:
            from runners.perplexity_runner import PerplexityRunner
            from runners.newsapi_runner import NewsAPIRunner
            print('‚úÖ Runner imports successful')
        except ImportError as e:
            print(f'‚ùå Runner import error: {e}')
            sys.exit(1)
        
        # Test feed_filter import specifically
        try:
            from utils.feed_filter import feed_filter
            print('‚úÖ Feed filter import successful')
        except ImportError as e:
            print(f'‚ùå Feed filter import error: {e}')
            sys.exit(1)
        "
        
        echo "‚úÖ All imports validated successfully"
    
    - name: Run application tests
      run: |
        echo "Running application tests..."
        python test_app.py http://localhost:8000 || echo "Tests will be run after deployment"
    
    - name: Test Docker build
      run: |
        echo "Testing Docker build..."
        docker build --platform linux/amd64 -t my-briefings-app:test .
        echo "‚úÖ Docker build test passed"

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Debug environment variables
      run: |
        echo "üîç Debugging environment variables..."
        echo "DROPLET_IP length: ${#DROPLET_IP}"
        echo "DROPLET_IP (first 10 chars): ${DROPLET_IP:0:10}..."
        echo "SSH_PRIVATE_KEY length: ${#SSH_PRIVATE_KEY}"
        echo "SSH_PRIVATE_KEY (first 50 chars): ${SSH_PRIVATE_KEY:0:50}..."
        echo "DROPLET_USER: $DROPLET_USER"
        
        if [ -z "$DROPLET_IP" ]; then
          echo "‚ùå DROPLET_IP is empty!"
          exit 1
        fi
        
        if [ -z "$SSH_PRIVATE_KEY" ]; then
          echo "‚ùå SSH_PRIVATE_KEY is empty!"
          exit 1
        fi
        
        echo "‚úÖ Environment variables are set"
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build Docker images for x86_64
      run: |
        echo "Building main app image..."
        docker build --platform linux/amd64 -t my-briefings-app:latest .
        echo "‚úÖ Main app image built successfully"
        
        echo "Building ingestion service image..."
        docker build --platform linux/amd64 -t my-briefings-ingestion:latest -f ./services/feed-ingestion/Dockerfile .
        echo "‚úÖ Ingestion service image built successfully"
        
        echo "üîç Listing built images..."
        docker images | grep my-briefings
    
    - name: Save Docker images
      run: |
        echo "Saving main app image..."
        docker save my-briefings-app:latest -o my-briefings-app.tar
        echo "‚úÖ Main app image saved"
        
        echo "Saving ingestion service image..."
        docker save my-briefings-ingestion:latest -o my-briefings-ingestion.tar
        echo "‚úÖ Ingestion service image saved"
        
        echo "üîç Listing saved image files..."
        ls -la *.tar
        echo "üìä Image file sizes:"
        du -h *.tar
    
    - name: Setup SSH
      run: |
        echo "üîß Setting up SSH..."
        mkdir -p ~/.ssh
        echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        echo "SSH key file created, size: $(wc -c < ~/.ssh/id_rsa) bytes"
        echo "SSH key file permissions: $(ls -la ~/.ssh/id_rsa)"
        echo "SSH key file line count: $(wc -l < ~/.ssh/id_rsa)"
        echo "SSH key first line: $(head -1 ~/.ssh/id_rsa)"
        echo "SSH key last line: $(tail -1 ~/.ssh/id_rsa)"
        echo "SSH key content (first 200 chars): $(head -c 200 ~/.ssh/id_rsa)"
        echo "SSH key content (last 200 chars): $(tail -c 200 ~/.ssh/id_rsa)"
        
        # Check if the key starts with the expected format
        if grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/id_rsa; then
          echo "‚úÖ SSH key has correct BEGIN marker"
        else
          echo "‚ùå SSH key missing BEGIN marker"
          echo "First few lines:"
          head -5 ~/.ssh/id_rsa
        fi
        
        if grep -q "END.*PRIVATE KEY" ~/.ssh/id_rsa; then
          echo "‚úÖ SSH key has correct END marker"
        else
          echo "‚ùå SSH key missing END marker"
          echo "Last few lines:"
          tail -5 ~/.ssh/id_rsa
        fi
        
        ssh-keyscan -H $DROPLET_IP >> ~/.ssh/known_hosts
        echo "SSH setup complete"
        
        echo "üîç Testing SSH connection..."
        ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 -o BatchMode=yes -o StrictHostKeyChecking=no $DROPLET_USER@$DROPLET_IP "echo 'SSH test successful'" || echo "SSH test failed"
    
    - name: Copy images to droplet
      run: |
        echo "üì§ Copying images to droplet..."
        echo "Using: scp *.tar $DROPLET_USER@$DROPLET_IP:~/"
        echo "DROPLET_USER: $DROPLET_USER"
        echo "DROPLET_IP: $DROPLET_IP"
        
        echo "üîç Checking files before copy..."
        ls -la *.tar
        
        scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no *.tar $DROPLET_USER@$DROPLET_IP:~/
        echo "‚úÖ Images copied successfully"
        
        echo "üîç Verifying files on droplet..."
        ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $DROPLET_USER@$DROPLET_IP "ls -la *.tar"
    
    - name: Copy Kubernetes manifests and env file
      run: |
        echo "üì§ Copying Kubernetes manifests..."
        scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -r k8s/ $DROPLET_USER@$DROPLET_IP:~/
        echo "‚úÖ Manifests copied successfully"
        
        echo "üì§ Copying .env file if it exists..."
        if [ -f .env ]; then
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no .env $DROPLET_USER@$DROPLET_IP:~/
          echo "‚úÖ .env file copied successfully"
        else
          echo "‚ö†Ô∏è  .env file not found locally, you'll need to create it on the droplet"
        fi
        
        echo "üì§ Copying setup script..."
        scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no scripts/setup-env.sh $DROPLET_USER@$DROPLET_IP:~/
        echo "‚úÖ Setup script copied successfully"
        
        echo "üì§ Copying log aggregator script..."
        scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no scripts/log-aggregator.sh $DROPLET_USER@$DROPLET_IP:~/
        echo "‚úÖ Log aggregator script copied successfully"
    
    - name: Deploy to k3s
      run: |
        ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $DROPLET_USER@$DROPLET_IP << 'EOF'
          set -e
          
          echo "üîß Using root user for k3s deployment..."
          
          echo "üêò Ensuring PostgreSQL is running..."
          if ! docker ps | grep -q postgres; then
            echo "Starting PostgreSQL container..."
            docker run -d \
              --name postgres \
              -e POSTGRES_DB=briefings_feed \
              -e POSTGRES_USER=fastapi \
              -e POSTGRES_PASSWORD=password \
              -p 5432:5432 \
              -v postgres_data:/var/lib/postgresql/data \
              postgres:15
          else
            echo "PostgreSQL is already running"
          fi
          
          echo "üßπ Cleaning up old images..."
          k3s ctr images rm docker.io/library/my-briefings-app:latest || true
          k3s ctr images rm docker.io/library/my-briefings-ingestion:latest || true
          
          echo "üì¶ Loading new images into k3s..."
          echo "Loading main app image..."
          k3s ctr images import ~/my-briefings-app.tar
          echo "‚úÖ Main app image loaded"
          
          echo "Loading ingestion service image..."
          k3s ctr images import ~/my-briefings-ingestion.tar
          echo "‚úÖ Ingestion service image loaded"
          
          echo "üîç Verifying images are loaded..."
          k3s ctr images ls | grep my-briefings
          
          echo "üìã Applying Kubernetes manifests..."
          kubectl apply -f ~/k8s/namespace.yaml
          
          echo "üîê Creating secrets from .env file..."
          # Read API keys from .env file on droplet
          if [ -f ~/.env ]; then
            echo "‚úÖ .env file found on droplet"
            PERPLEXITY_API_KEY=$(grep "^PERPLEXITY_API_KEY=" ~/.env | cut -d'=' -f2- | tr -d '"' | tr -d "'")
            NEWS_API_KEY=$(grep "^NEWS_API_KEY=" ~/.env | cut -d'=' -f2- | tr -d '"' | tr -d "'")
            
            if [ -n "$PERPLEXITY_API_KEY" ]; then
              echo "‚úÖ PERPLEXITY_API_KEY found in .env (length: ${#PERPLEXITY_API_KEY})"
            else
              echo "‚ö†Ô∏è  Warning: PERPLEXITY_API_KEY not found in .env, using empty value"
              PERPLEXITY_API_KEY=""
            fi
            
            if [ -n "$NEWS_API_KEY" ]; then
              echo "‚úÖ NEWS_API_KEY found in .env (length: ${#NEWS_API_KEY})"
            else
              echo "‚ö†Ô∏è  Warning: NEWS_API_KEY not found in .env, using empty value"
              NEWS_API_KEY=""
            fi
          else
            echo "‚ö†Ô∏è  Warning: .env file not found on droplet, using empty values"
            PERPLEXITY_API_KEY=""
            NEWS_API_KEY=""
          fi
          
          # Create the api-secrets secret using kubectl create
          kubectl create secret generic api-secrets \
            --namespace=my-briefings \
            --from-literal=perplexity-api-key="$PERPLEXITY_API_KEY" \
            --from-literal=news-api-key="$NEWS_API_KEY" \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ Kubernetes secret 'api-secrets' created/updated with both Perplexity and NewsAPI keys"
          
          kubectl apply -f ~/k8s/deployment.yaml
          kubectl apply -f ~/k8s/service.yaml
          kubectl apply -f ~/k8s/ingestion-deployment.yaml
          kubectl apply -f ~/k8s/ingestion-service.yaml
          kubectl apply -f ~/k8s/celery-worker-deployment.yaml
          kubectl apply -f ~/k8s/celery-beat-deployment.yaml
          kubectl apply -f ~/k8s/ingress.yaml
          
          echo "üîÑ Rolling out deployments..."
          kubectl rollout restart deployment/my-briefings-app -n my-briefings
          kubectl rollout restart deployment/my-briefings-ingestion -n my-briefings
          kubectl rollout restart deployment/my-briefings-celery-worker -n my-briefings
          kubectl rollout restart deployment/my-briefings-celery-beat -n my-briefings
          
          echo "‚è≥ Waiting for deployments to be ready..."
          kubectl rollout status deployment/my-briefings-app -n my-briefings --timeout=300s
          kubectl rollout status deployment/my-briefings-ingestion -n my-briefings --timeout=300s
          kubectl rollout status deployment/my-briefings-celery-worker -n my-briefings --timeout=300s
          kubectl rollout status deployment/my-briefings-celery-beat -n my-briefings --timeout=300s
          
          echo "üîç Checking pod status..."
          kubectl get pods -n my-briefings
          
          echo "‚úÖ Deployment completed successfully!"
          
          echo "üìä Setting up log aggregator..."
          chmod +x ~/log-aggregator.sh
          mkdir -p /var/log/my-briefings
          echo "‚úÖ Log aggregator setup completed!"
        EOF
    
    - name: Health check
      run: |
        echo "Waiting for app to be ready..."
        sleep 30
        
        # Test the health endpoint
        for i in {1..10}; do
          if curl -f http://$DROPLET_IP:30100/health; then
            echo "‚úÖ Health check passed!"
            break
          else
            echo "‚è≥ Health check failed, retrying in 10 seconds... (attempt $i/10)"
            sleep 10
          fi
        done
    
    - name: Run integration tests
      run: |
        echo "Running integration tests..."
        python test_app.py http://$DROPLET_IP:30100
    
    - name: Copy cleanup script
      if: always()
      run: |
        scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no scripts/cleanup-remote.sh $DROPLET_USER@$DROPLET_IP:~/

    - name: Cleanup
      if: always()
      run: |
        ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no $DROPLET_USER@$DROPLET_IP 'bash ~/cleanup-remote.sh && rm -f ~/cleanup-remote.sh' 